# gestor_tiendas.py
# -*- coding: utf-8 -*-

import tkinter as tk
from tkinter import ttk, messagebox
import sqlite3
import json
import os


# DatabaseManager

class DatabaseManager:
    def __init__(self, db_path='tiendas.db'):
        # Conexión (allowing same-thread use by default; ok para apps sencillas)
        self.db_path = db_path
        self.conn = sqlite3.connect(self.db_path)
        self.cursor = self.conn.cursor()
        self.crear_tabla()

    def crear_tabla(self):
        self.cursor.execute("""
            CREATE TABLE IF NOT EXISTS Tienda (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nombre TEXT NOT NULL,
                horario TEXT NOT NULL,
                ubicacion TEXT,
                completada INTEGER DEFAULT 0
            )
        """)
        self.conn.commit()

    def añadir_tienda(self, nombre, horario, ubicacion):
        self.cursor.execute(
            "INSERT INTO Tienda (nombre, horario, ubicacion, completada) VALUES (?, ?, ?, 0)",
            (nombre, horario, ubicacion)
        )
        self.conn.commit()
        return self.cursor.lastrowid

    def eliminar_tienda(self, tienda_id):
        self.cursor.execute("DELETE FROM Tienda WHERE id = ?", (tienda_id,))
        self.conn.commit()

    def modificar_tienda(self, tienda_id, nombre, horario, ubicacion):
        self.cursor.execute(
            "UPDATE Tienda SET nombre = ?, horario = ?, ubicacion = ? WHERE id = ?",
            (nombre, horario, ubicacion, tienda_id)
        )
        self.conn.commit()

    def marcar_completada(self, tienda_id, estado):
        # estado debe ser 0 o 1
        estado_val = 1 if estado else 0
        self.cursor.execute("UPDATE Tienda SET completada = ? WHERE id = ?", (estado_val, tienda_id))
        self.conn.commit()

    def actualizar_lista(self, termino=None):
        if termino:
            t = f"%{termino}%"
            self.cursor.execute(
                "SELECT id, nombre, horario, ubicacion, completada FROM Tienda "
                "WHERE nombre LIKE ? OR ubicacion LIKE ? OR horario LIKE ? ORDER BY id DESC",
                (t, t, t)
            )
        else:
            self.cursor.execute(
                "SELECT id, nombre, horario, ubicacion, completada FROM Tienda ORDER BY id DESC"
            )
        return self.cursor.fetchall()

    def obtener_todas_las_tiendas(self):
        self.cursor.execute("SELECT id, nombre, horario, ubicacion, completada FROM Tienda ORDER BY id DESC")
        return self.cursor.fetchall()

    def cerrar(self):
        try:
            self.conn.commit()
            self.conn.close()
        except Exception:
            pass



# App (Tkinter GUI)

class App:
    def __init__(self, ventana):
        self.ventana = ventana
        self.ventana.title("Gestor de Tiendas")
        self.ventana.geometry("800x520")

        # instancia DB
        self.db = DatabaseManager('tiendas.db')

        # guardamos los registros mostrados para referencia
        self.tiendas_mostradas = []

        self.crear_interfaz()
        self.actualizar_lista_gui()

    def crear_interfaz(self):
        # ---- menú ----
        barra = tk.Menu(self.ventana)
        self.ventana.config(menu=barra)

        menu_archivo = tk.Menu(barra, tearoff=0)
        barra.add_cascade(label="Archivo", menu=menu_archivo)
        menu_archivo.add_command(label="Exportar a JSON", command=self.exportar_json)
        menu_archivo.add_command(label="Importar desde JSON", command=self.importar_json)
        menu_archivo.add_separator()
        menu_archivo.add_command(label="Salir", command=self.on_close)

        menu_ayuda = tk.Menu(barra, tearoff=0)
        barra.add_cascade(label="Ayuda", menu=menu_ayuda)
        menu_ayuda.add_command(label="Acerca de...", command=self.mostrar_acerca_de)

        # ---- formulario ----
        frame_form = tk.Frame(self.ventana, padx=10, pady=8)
        frame_form.pack(fill=tk.X)

        tk.Label(frame_form, text="Nombre:").grid(row=0, column=0, sticky="w", padx=5, pady=4)
        self.campo_nomb = tk.Entry(frame_form)
        self.campo_nomb.grid(row=0, column=1, sticky="ew", padx=5, pady=4)

        tk.Label(frame_form, text="Ubicación:").grid(row=0, column=2, sticky="w", padx=5, pady=4)
        self.campo_ubic = tk.Entry(frame_form)
        self.campo_ubic.grid(row=0, column=3, sticky="ew", padx=5, pady=4)

        tk.Label(frame_form, text="Horario:").grid(row=1, column=0, sticky="w", padx=5, pady=4)
        self.combo_hora = ttk.Combobox(frame_form, values=["Baja", "Media", "Alta"], state="readonly")
        self.combo_hora.grid(row=1, column=1, sticky="ew", padx=5, pady=4)
        self.combo_hora.current(1)  # "Media" por defecto

        # Asegurar que las columnas del frame se expandan bien
        frame_form.grid_columnconfigure(1, weight=1)
        frame_form.grid_columnconfigure(3, weight=1)

        # ---- botones ----
        frame_btn = tk.Frame(self.ventana, padx=10, pady=6)
        frame_btn.pack(fill=tk.X)

        tk.Button(frame_btn, text="Añadir tienda", command=self.añadir_tienda).pack(side=tk.LEFT, padx=5)
        tk.Button(frame_btn, text="Modificar seleccionada", command=self.modificar_tienda_seleccionada).pack(side=tk.LEFT, padx=5)
        tk.Button(frame_btn, text="Eliminar seleccionada", command=self.eliminar_tienda_seleccionada).pack(side=tk.LEFT, padx=5)
        tk.Button(frame_btn, text="Marcar/Desmarcar completada", command=self.toggle_completada_seleccionada).pack(side=tk.LEFT, padx=5)

        # ---- búsqueda ----
        frame_bus = tk.Frame(self.ventana, padx=10, pady=6)
        frame_bus.pack(fill=tk.X)

        tk.Label(frame_bus, text="Buscar:").pack(side=tk.LEFT, padx=5)
        self.campo_busqueda = tk.Entry(frame_bus)
        self.campo_busqueda.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)

        tk.Button(frame_bus, text="Buscar", command=self.buscar_tiendas).pack(side=tk.LEFT, padx=5)
        tk.Button(frame_bus, text="Limpiar", command=self.limpiar_busqueda).pack(side=tk.LEFT, padx=5)

        #  lista (Treeview) 
        frame_lista = tk.Frame(self.ventana, padx=10, pady=6)
        frame_lista.pack(fill=tk.BOTH, expand=True)

        columnas = ("id", "nombre", "horario", "ubicacion", "completada")
        self.tree = ttk.Treeview(frame_lista, columns=columnas, show="headings", selectmode="browse")
        headings = {"id": "ID", "nombre": "Nombre", "horario": "Horario", "ubicacion": "Ubicación", "completada": "Completada"}
        for col in columnas:
            self.tree.heading(col, text=headings[col])
            # columnas con ancho razonable
        self.tree.column("id", width=50, anchor="center")
        self.tree.column("nombre", width=260)
        self.tree.column("horario", width=90, anchor="center")
        self.tree.column("ubicacion", width=240)
        self.tree.column("completada", width=100, anchor="center")

        vsb = ttk.Scrollbar(frame_lista, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscroll=vsb.set)
        vsb.pack(side=tk.RIGHT, fill=tk.Y)
        self.tree.pack(fill=tk.BOTH, expand=True)

  
    # Operaciones CRUD
 
    def añadir_tienda(self):
        nombre = self.campo_nomb.get().strip()
        ubic = self.campo_ubic.get().strip()
        horario = self.combo_hora.get().strip()

        if not nombre:
            messagebox.showwarning("Campo Vacío", "El nombre no puede estar vacío.")
            return

        try:
            self.db.añadir_tienda(nombre, horario, ubic)
            self.limpiar_campos()
            self.actualizar_lista_gui()
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo añadir la tienda: {e}")

    def limpiar_campos(self):
        self.campo_nomb.delete(0, tk.END)
        self.campo_ubic.delete(0, tk.END)
        try:
            self.combo_hora.current(1)
        except Exception:
            pass

    def actualizar_lista_gui(self, termino_busqueda=None):
        # limpiar Treeview
        for item in self.tree.get_children():
            self.tree.delete(item)

        tiendas = self.db.actualizar_lista(termino_busqueda)
        self.tiendas_mostradas = tiendas

        for tienda in tiendas:
            tid, nombre, horario, ubicacion, completada = tienda
            estado = "Sí" if completada else "No"
            self.tree.insert("", tk.END, values=(tid, nombre, horario, ubicacion, estado))

    def get_id_seleccionado(self):
        sel = self.tree.selection()
        if not sel:
            return None
        vals = self.tree.item(sel[0], "values")
        try:
            return int(vals[0])
        except Exception:
            return None

    def eliminar_tienda_seleccionada(self):
        tid = self.get_id_seleccionado()
        if tid is None:
            messagebox.showwarning("Sin selección", "Selecciona una tienda primero.")
            return
        if not messagebox.askyesno("Confirmar", "¿Eliminar la tienda seleccionada?"):
            return
        try:
            self.db.eliminar_tienda(tid)
            self.actualizar_lista_gui()
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo eliminar: {e}")

    def toggle_completada_seleccionada(self):
        tid = self.get_id_seleccionado()
        if tid is None:
            messagebox.showwarning("Sin selección", "Selecciona una tienda primero.")
            return
        estado_actual = next((t[4] for t in self.tiendas_mostradas if t[0] == tid), 0)
        nuevo_estado = 0 if estado_actual else 1
        try:
            self.db.marcar_completada(tid, nuevo_estado)
            self.actualizar_lista_gui()
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo actualizar: {e}")

    def modificar_tienda_seleccionada(self):
        tid = self.get_id_seleccionado()
        if tid is None:
            messagebox.showwarning("Sin selección", "Selecciona una tienda primero.")
            return

        tienda = next((t for t in self.tiendas_mostradas if t[0] == tid), None)
        if not tienda:
            messagebox.showerror("Error", "No se pudo obtener la tienda seleccionada.")
            return

        _, nombre, horario, ubicacion, _ = tienda

        # ventana de edición
        editar = tk.Toplevel(self.ventana)
        editar.title("Modificar Tienda")
        editar.geometry("380x220")
        editar.transient(self.ventana)
        editar.grab_set()

        tk.Label(editar, text="Nombre:").pack(anchor="w", padx=10, pady=(10, 0))
        ent_nombre = tk.Entry(editar)
        ent_nombre.pack(fill=tk.X, padx=10, pady=(0, 6))
        ent_nombre.insert(0, nombre)

        tk.Label(editar, text="Ubicación:").pack(anchor="w", padx=10, pady=(6, 0))
        ent_ubic = tk.Entry(editar)
        ent_ubic.pack(fill=tk.X, padx=10, pady=(0, 6))
        ent_ubic.insert(0, ubicacion if ubicacion else "")

        tk.Label(editar, text="Horario:").pack(anchor="w", padx=10, pady=(6, 0))
        combo = ttk.Combobox(editar, values=["Baja", "Media", "Alta"], state="readonly")
        combo.pack(fill=tk.X, padx=10, pady=(0, 8))
        # seleccionar valor seguro
        try:
            combo.current(["Baja", "Media", "Alta"].index(horario))
        except Exception:
            combo.current(1)

        def guardar():
            nuevo_nombre = ent_nombre.get().strip()
            nueva_ubic = ent_ubic.get().strip()
            nuevo_hora = combo.get().strip()
            if not nuevo_nombre:
                messagebox.showwarning("Campo vacío", "El nombre no puede estar vacío.")
                return
            try:
                self.db.modificar_tienda(tid, nuevo_nombre, nuevo_hora, nueva_ubic)
                editar.destroy()
                self.actualizar_lista_gui()
            except Exception as e:
                messagebox.showerror("Error", f"No se pudo modificar: {e}")

        tk.Button(editar, text="Guardar cambios", command=guardar).pack(pady=10)

  
    # BUSCAR / LIMPIAR
  
    def buscar_tiendas(self):
        termino = self.campo_busqueda.get().strip()
        self.actualizar_lista_gui(termino if termino else None)

    def limpiar_busqueda(self):
        self.campo_busqueda.delete(0, tk.END)
        self.actualizar_lista_gui()

    
    # EXPORT / IMPORT JSON

    def exportar_json(self):
        try:
            datos = self.db.obtener_todas_las_tiendas()
            lista = []
            for t in datos:
                lista.append({
                    "id": t[0],
                    "nombre": t[1],
                    "horario": t[2],
                    "ubicacion": t[3],
                    "completada": t[4]
                })
            with open("backup_tiendas.json", "w", encoding="utf-8") as f:
                json.dump(lista, f, indent=4, ensure_ascii=False)
            messagebox.showinfo("Exportado", "Datos exportados a backup_tiendas.json")
        except Exception as e:
            messagebox.showerror("Error de exportación", f"No se pudo exportar: {e}")

    def importar_json(self):
        if not os.path.exists("backup_tiendas.json"):
            messagebox.showerror("Error", "No existe el archivo backup_tiendas.json")
            return
        try:
            with open("backup_tiendas.json", "r", encoding="utf-8") as f:
                lista = json.load(f)
            # Insertamos cada registro (ignoramos id; completada quedará en 0)
            for item in lista:
                nombre = item.get("nombre", "").strip()
                horario = item.get("horario", "Media")
                ubic = item.get("ubicacion", "")
                if nombre:
                    self.db.añadir_tienda(nombre, horario, ubic)
            self.actualizar_lista_gui()
            messagebox.showinfo("Importado", "Datos importados desde backup_tiendas.json")
        except Exception as e:
            messagebox.showerror("Error de importación", f"No se pudo importar: {e}")

   
    # ACERCA DE & CIERRE
 
    def mostrar_acerca_de(self):
        v = tk.Toplevel(self.ventana)
        v.title("Acerca del Gestor")
        v.geometry("320x160")
        v.transient(self.ventana)
        v.grab_set()
        tk.Label(v, text="Gestor de Tiendas v1.0").pack(pady=12)
        tk.Label(v, text="Desarrollado por: [Tu Nombre]").pack(pady=4)
        tk.Button(v, text="Cerrar", command=v.destroy).pack(pady=12)

    def on_close(self):
        # Cerrar BD y salir
        try:
            self.db.cerrar()
        except Exception:
            pass
        try:
            self.ventana.destroy()
        except Exception:
            pass


# MAIN

if __name__ == "__main__":
    root = tk.Tk()
    app = App(root)
    root.protocol("WM_DELETE_WINDOW", app.on_close)
    root.mainloop()
